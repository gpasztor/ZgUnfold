//#define ZgUnfold_c

//#include "RooUnfoldResponse.h"
//#include "RooUnfoldBayes.h"

/*
#include "/home/rebeklill/RooUnfold/src/RooUnfoldResponse.h"
#include "/home/rebeklill/RooUnfold/src/RooUnfoldBayes.h"
#include "/home/rebeklill/RooUnfold/src/RooUnfoldSvd.h"
#include "/home/rebeklill/RooUnfold/src/RooUnfoldBinByBin.h"
#include "/home/rebeklill/RooUnfold/src/RooUnfoldTUnfold.h"
#include "/home/rebeklill/root/include/TMath.h"
*/

#include "/opt/local/libexec/RooUnfold/src/RooUnfoldResponse.h"
#include "/opt/local/libexec/RooUnfold/src/RooUnfoldBayes.h"
#include "/opt/local/libexec/RooUnfold/src/RooUnfoldSvd.h"
#include "/opt/local/libexec/RooUnfold/src/RooUnfoldBinByBin.h"
#include "/opt/local/libexec/RooUnfold/src/RooUnfoldTUnfold.h"

using namespace TMath;
using namespace TRandom;

int ZgUnfold(int channel=0, int errorTreatment=3, bool smooth=false, bool
MCfake=false, bool useProcessID=true, int smear=0, int scale=0/*, bool doPt=true, bool doMass=true*/)
{

stringstream nameFragmSS;
nameFragmSS << "_ch" << channel << "_err" << errorTreatment << "_sm" << smooth << "_MCf" << MCfake << "_PID" << useProcessID << "_smear"
<< smear << "_scale" << scale;
cout << "_ch" << channel << "_err" << errorTreatment << "_sm" << smooth << "_MCf" << MCfake << "_PID" << useProcessID << "_smear"
<< smear << "_scale" << scale << "_NewMassBins" << endl;
string nameFragm=nameFragmSS.str();
cout << "nameFragm: " << nameFragm << endl;

gSystem->Load("libRooUnfold");

int lepMass=0;
if(channel==0) lepMass=0.000511;
else if(channel==1) lepMass=0.105658;

/*
const int nbinsD= 11;
const int nbinsMC = 11;
const float xbinsD[nbinsD] = {15,20,25,30,35,40,60,90,120,500,1000};
const float xbinsMC[nbinsMC] = {15,20,25,30,35,40,60,90,120,500,1000};
*/
const int nbinsD= 13;
const int nbinsMC = 13;
const float xbinsD[nbinsD] = {10,15,20,25,30,35,40,50,60,90,120,500,1000};
const float xbinsMC[nbinsMC] = {10,15,20,25,30,35,40,50,60,90,120,500,1000};

const int nbinsDm = nbinsD-1;
const int nbinsMCm = nbinsMC-1;

float fakeRateB0[nbinsDm] = {0.138,0.138,0.167,0.141,0.166,0.183,0.204,0.204,0.160,0.103,0.083,0.083};
float fakeRateB1[nbinsDm] = {0.118,0.118,0.115,0.113,0.139,0.174,0.192,0.192,0.149,0.066,0.104,0.104};
float fakeRateE0[nbinsDm] = {0.304,0.304,0.290,0.315,0.384,0.282,0.363,0.363,0.205,0.183,0.175,0.175}; 
float fakeRateE1[nbinsDm] = {0.276,0.276,0.250,0.241,0.269,0.337,0.373,0.373,0.235,0.126,0.083,0.083};

float fakeRateMCB0[nbinsDm] = {0.161,0.161,0.180,0.160,0.210,0.220,0.199,0.199,0.113,0.141,0.066,0.066};
float fakeRateMCB1[nbinsDm] = {0.148,0.148,0.161,0.129,0.169,0.181,0.191,0.191,0.142,0.145,0.09,0.09};
float fakeRateMCE0[nbinsDm] = {0.357,0.357,0.314,0.286,0.415,0.382,0.340,0.340,0.368,0.294,0.320,0.320};
float fakeRateMCE1[nbinsDm] = {0.336,0.336,0.304,0.237,0.306,0.428,0.333,0.333,0.380,0.355,0.369,0.369};
/*
float fakeRateB0[nbinsDm] = {0.138,0.167,0.141,0.166,0.183,0.204,0.160,0.103,0.083,0.083};
float fakeRateB1[nbinsDm] = {0.118,0.115,0.113,0.139,0.174,0.192,0.149,0.066,0.104,0.104};
float fakeRateE0[nbinsDm] = {0.304,0.290,0.315,0.384,0.282,0.363,0.205,0.183,0.175,0.175}; 
float fakeRateE1[nbinsDm] = {0.276,0.250,0.241,0.269,0.337,0.373,0.235,0.126,0.083,0.083};

float fakeRateMCB0[nbinsDm] = {0.161,0.180,0.160,0.210,0.220,0.199,0.113,0.141,0.066,0.066};
float fakeRateMCB1[nbinsDm] = {0.148,0.161,0.129,0.169,0.181,0.191,0.142,0.145,0.09,0.09};
float fakeRateMCE0[nbinsDm] = {0.357,0.314,0.286,0.415,0.382,0.340,0.368,0.294,0.320,0.320};
float fakeRateMCE1[nbinsDm] = {0.336,0.304,0.237,0.306,0.428,0.333,0.380,0.355,0.369,0.369};
*/
if(MCfake){
  for(int i=0;i<nbinsDm;i++){
    fakeRateB0[i] = fakeRateMCB0[i];
    fakeRateB1[i] = fakeRateMCB1[i];
    fakeRateE0[i] = fakeRateMCE0[i];
    fakeRateE1[i] = fakeRateMCE1[i];
  }
}
cout << "fakeRateB0: " << fakeRateB0[0] << " " << fakeRateB0[1] << endl; 

/*
const int nbinsMassD= 12;
const int nbinsMassMC = 12;
const float xbinsMassD[nbinsMassD]={50,60,70,80,90,100,125,150,200,300,500,1000};
const float xbinsMassMC[nbinsMassMC] = {50,60,70,80,90,100,125,150,200,300,500,1000};
*/
const int nbinsMassD= 16;
const int nbinsMassMC = 16;
const float xbinsMassD[nbinsMassD]={50,60,70,80,85,90,95,110,125,140,160,190,230,300,500,1000};
const float xbinsMassMC[nbinsMassMC] = {50,60,70,80,85,90,95,110,125,140,160,190,230,300,500,1000};
const int nbinsMassDm = nbinsMassD-1;
const int nbinsMassMCm = nbinsMassMC-1;

TFile *fileD = 0;
TFile *fileMC = 0;
if (channel == 0) {
  fileD = TFile::Open("13TeV_Zg/data_ch0.root");
  fileMC = TFile::Open("13TeV_Zg/mc_ch0.root");
} else if (channel == 1) {
  fileD = TFile::Open("13TeV_Zg/data_ch1.root");
  fileMC = TFile::Open("13TeV_Zg/mc_ch1.root");
} else {
  cout << "Please input 0 or 1!" << endl;
}
if(!fileD || !fileD->IsOpen() || !fileMC || !fileMC->IsOpen() ) { 
  cout<<"Cannot open file"<<endl;
  return 0;
}

TTree *treeD = (TTree*) fileD->Get("tZg");
TTree *treeMC = (TTree*) fileMC->Get("tZg");
 
float phoPtD,phoEtaD,phoSCEtaD,phoPhiD;
float lepPtD[2],lepEtaD[2],lepSCEtaD[2],lepPhiD[2];
float mllgD,mllD;
int isEBEED; 
treeD->SetBranchAddress("phoPt",&phoPtD);
treeD->SetBranchAddress("phoEta",&phoEtaD);
treeD->SetBranchAddress("phoSCEta",&phoSCEtaD);
treeD->SetBranchAddress("phoPhi",&phoPhiD);
treeD->SetBranchAddress("lepPt",&lepPtD);
treeD->SetBranchAddress("lepEta",&lepEtaD);
treeD->SetBranchAddress("lepSCEta",&lepSCEtaD);
treeD->SetBranchAddress("lepPhi",&lepPhiD);
treeD->SetBranchAddress("mllg",&mllgD);
treeD->SetBranchAddress("mll",&mllD);
treeD->SetBranchAddress("isEBEE",&isEBEED);

float phoPtMC,phoEtaMC,phoSCEtaMC,phoPhiMC;
float lepPtMC[2],lepEtaMC[2],lepSCEtaMC[2],lepPhiMC[2];
float mllgMC,mllMC;
int isEBEEMC; 
float mcPhoPtMC,mcPhoEtaMC,mcPhoPhiMC;
float mcLepPtMC[2],mcLepEtaMC[2],mcLepPhiMC[2];
float puwei,mcwei,genwei;
int processID;
treeMC->SetBranchAddress("phoPt",&phoPtMC);
treeMC->SetBranchAddress("phoEta",&phoEtaMC);
treeMC->SetBranchAddress("phoSCEta",&phoSCEtaMC);
treeMC->SetBranchAddress("phoPhi",&phoPhiMC);
treeMC->SetBranchAddress("lepPt",&lepPtMC);
treeMC->SetBranchAddress("lepEta",&lepEtaMC);
treeMC->SetBranchAddress("lepSCEta",&lepSCEtaMC);
treeMC->SetBranchAddress("lepPhi",&lepPhiMC);
treeMC->SetBranchAddress("mllg",&mllgMC);
treeMC->SetBranchAddress("mll",&mllMC);
treeMC->SetBranchAddress("isEBEE",&isEBEEMC);
treeMC->SetBranchAddress("mcPhoPt",&mcPhoPtMC);
treeMC->SetBranchAddress("mcPhoEta",&mcPhoEtaMC);
treeMC->SetBranchAddress("mcPhoPhi",&mcPhoPhiMC);
treeMC->SetBranchAddress("mcLepPt",&mcLepPtMC);
treeMC->SetBranchAddress("mcLepEta",&mcLepEtaMC);
treeMC->SetBranchAddress("mcLepPhi",&mcLepPhiMC);
treeMC->SetBranchAddress("puwei",&puwei);
treeMC->SetBranchAddress("mcwei",&mcwei);
treeMC->SetBranchAddress("genwei",&genwei);
treeMC->SetBranchAddress("processID",&processID);

TH1F *inHist = new TH1F("inHist","inHist", nbinsDm, xbinsD);
TH1F *inHistBkg = new TH1F("inHistBkg","inHistBkg", nbinsDm, xbinsD);
TH1F *inHistMC = new TH1F("inHistMC","inHistMC", nbinsDm, xbinsD);
TH1F *inHistMCBkg = new TH1F("inHistMCBkg","inHistMCBkg", nbinsDm, xbinsD);
TH1F *inHistMCPhoBkg = new TH1F("inHistMCPhoBkg","inHistMCPhoBkg", nbinsDm, xbinsD);
TH1F *trueHistMC = new TH1F("trueHistMC","trueHistMC", nbinsMCm, xbinsD);
TH2F *responseMC = new TH2F("responseMC","responseMC", nbinsDm, xbinsD, nbinsMCm, xbinsMC);
TH1F *outHist = new TH1F("outHist","outHist", nbinsMCm, xbinsMC);
TH1F *outHistMC = new TH1F("outHistMC","outHistMC", nbinsMCm, xbinsMC);

TH1F *inHistMass = new TH1F("inHistMass","inHistMass", nbinsMassDm, xbinsMassD);
TH1F *inHistMassBkg = new TH1F("inHistMassBkg","inHistMassBkg", nbinsMassDm, xbinsMassD);
TH1F *inHistMassMC = new TH1F("inHistMassMC","inHistMassMC", nbinsMassDm, xbinsMassD);
TH1F *inHistMassMCBkg = new TH1F("inHistMassMCBkg","inHistMassMCBkg", nbinsMassDm, xbinsMassD);
TH1F *inHistMassMCPhoBkg = new TH1F("inHistMassMCPhoBkg","inHistMassMCPhoBkg", nbinsMassDm, xbinsMassD);
TH1F *trueHistMassMC = new TH1F("trueHistMassMC","trueHistMassMC", nbinsMassMCm, xbinsMassD);
TH2F *responseMassMC = new TH2F("responseMassMC","responseMassMC", nbinsMassDm, xbinsMassD, nbinsMassMCm, xbinsMassMC);
TH1F *outHistMass = new TH1F("outHistMass","outHistMass", nbinsMassMCm, xbinsMassMC);
TH1F *outHistMassMC = new TH1F("outHistMassMC","outHistMassMC", nbinsMassMCm, xbinsMassMC);

TH1F *histCheckMassMC = new TH1F("histCheckMassMC","histCheckMassMC", 200,0,1000);
TH1F *histCheckMass = new TH1F("histCheckMass","histCheckMass", 200,0,1000);
TH1F *histCheckMassNtMC = new TH1F("histCheckMassNtMC","histCheckMassNtMC", 200,0,1000);
TH1F *histCheckMassNt = new TH1F("histCheckMassNt","histCheckMassNt", 200,0,1000);
TH1F *histCheckMllMC = new TH1F("histCheckMllMC","histCheckMllMC", 200,0,1000);
TH1F *histCheckMll = new TH1F("histCheckMll","histCheckMll", 200,0,1000);
TH1F *histCheckMllNtMC = new TH1F("histCheckMllNtMC","histCheckMllNtMC", 200,0,1000);
TH1F *histCheckMllNt = new TH1F("histCheckMllNt","histCheckMllNt", 200,0,1000);
TH2F *hist2DCheckMassMC = new TH2F("hist2DCheckMassMC","hist2DCheckMassMC", 200,0,1000, 200,0,1000);
TH2F *hist2DCheckMass = new TH2F("hist2DCheckMass","hist2DCheckMass", 200,0,1000, 200,0,1000);
TH2F *hist2DCheckMllMC = new TH2F("hist2DCheckMllMC","hist2DCheckMllMC", 200,0,1000, 200,0,1000);
TH2F *hist2DCheckMll = new TH2F("hist2DCheckMll","hist2DCheckMll", 200,0,1000, 200,0,1000);

//TH1F *histCheckMassMC = new TH1F("histCheckMassMC","histCheckMassMC", nbinsMassDm, xbinsMassD);
//TH1F *histCheckMass = new TH1F("histCheckMass","histCheckMass", nbinsMassDm, xbinsMassD);
//TH1F *histCheckMllMC = new TH1F("histCheckMllMC","histCheckMllMC", nbinsMassDm, xbinsMassD);
//TH1F *histCheckMll = new TH1F("histCheckMll","histCheckMll", nbinsMassDm, xbinsMassD);
//TH1F *histCheckMllNtMC = new TH1F("histCheckMllNtMC","histCheckMllNtMC", nbinsMassDm, xbinsMassD);
//TH1F *histCheckMllNt = new TH1F("histCheckMllNt","histCheckMllNt", nbinsMassDm, xbinsMassD);
//TH2F *hist2DCheckMassMC = new TH2F("hist2DCheckMassMC","hist2DCheckMassMC", nbinsMassDm, xbinsMassD, nbinsMassMCm, xbinsMassMC);
//TH2F *hist2DCheckMass = new TH2F("hist2DCheckMass","hist2DCheckMass", nbinsMassDm, xbinsMassD, nbinsMassMCm, xbinsMassMC);
//TH2F *hist2DCheckMllMC = new TH2F("hist2DCheckMllMC","hist2DCheckMllMC", nbinsMassDm, xbinsMassD, nbinsMassMCm, xbinsMassMC);
//TH2F *hist2DCheckMll = new TH2F("hist2DCheckMll","hist2DCheckMll", nbinsMassDm, xbinsMassD, nbinsMassMCm, xbinsMassMC);

RooUnfoldResponse response(inHist,outHist);
RooUnfoldResponse responseMass(inHistMass,outHistMass);
 
//TH1F* inHistProj; 
//TH1F* inHistMCProj; 
//TH1F* trueHistMCProj; 
//TH2F* responseMCProj; 
treeD->Project("inHistProj","phoPt");   
treeMC->Project("inHistMCProj","phoPt","(puwei*mcwei*genwei)*(1)");   
treeMC->Project("trueHistMCProj","mcPhoPt","(puwei*mcwei*genwei)*(1)");   
treeMC->Project("responseMCProj","phoPt:mcPhoPt","(puwei*mcwei*genwei)*(1)");
//TH1F* inHistMassProj; 
//TH1F* inHistMassMCProj; 
//TH1F* trueHistMassMCProj; 
//TH2F* responseMassMCProj; 
treeD->Project("inHistMassProj","mllg","phoPt>15");   
treeMC->Project("inHistMassMCProj","mllg","(puwei*mcwei*genwei)*(phoPt>15)");   
//treeMC->Project("trueHistMassMCProj","???","(puwei*mcwei*genwei)*(phoPt>15)");   
//treeMC->Project("responseMassMCProj","mllg:???","(puwei*mcwei*genwei)*(phoPt>15)");

int nMC = treeMC->GetEntries();
for (int i=0;i<nMC;i++){
  treeMC->GetEntry(i);
  inHistMCBkg->Fill(Min((float)phoPtMC,(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  if(phoPtMC>15) inHistMassMCBkg->Fill(Min((float)mllgMC,(float)(xbinsMassD[nbinsMassDm]-0.1)),puwei*mcwei*genwei);
  if(mcPhoPtMC<0) continue;
  inHistMCPhoBkg->Fill(Min((float)phoPtMC,(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  if(phoPtMC>15) inHistMassMCPhoBkg->Fill(Min((float)mllgMC,(float)(xbinsMassD[nbinsMassDm]-0.1)),puwei*mcwei*genwei);  
  if(useProcessID && processID!=1) continue;
  if(smear==0 && scale==0) inHistMC->Fill(Min((float)phoPtMC,(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  else if(smear==0) inHistMC->Fill(Min((float)(phoPtMC*(1.+scale*0.01)),(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  else if(scale==0) inHistMC->Fill(Min((float)(phoPtMC+gRandom->Gaus(0,smear*0.01*phoPtMC)),(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  else inHistMC->Fill(Min((float)(phoPtMC+gRandom->Gaus(scale*0.01*phoPtMC,smear*0.01*phoPtMC)),(float)(xbinsD[nbinsDm]-0.1)),puwei*mcwei*genwei);
  trueHistMC->Fill(Min((float)mcPhoPtMC,(float)(xbinsMC[nbinsMCm]-0.1)),puwei*mcwei*genwei);
  responseMC->Fill(Min((float)phoPtMC,(float)(xbinsD[nbinsDm]-0.1)),Min((float)mcPhoPtMC,(float)(xbinsMC[nbinsMCm]-0.1)),puwei*mcwei*genwei);
  
  if(phoPtMC>15) {
    TLorentzVector mcLep1MC;
    mcLep1MC.SetPtEtaPhiM(mcLepPtMC[0], mcLepEtaMC[0], mcLepPhiMC[0], lepMass);
    TLorentzVector mcLep2MC;
    mcLep2MC.SetPtEtaPhiM(mcLepPtMC[1], mcLepEtaMC[1], mcLepPhiMC[1], lepMass);			
    TLorentzVector mcPhoMC;
    mcPhoMC.SetPtEtaPhiM(mcPhoPtMC, mcPhoEtaMC, mcPhoPhiMC, 0);
    TLorentzVector mcPhoDiLep;
    mcPhoDiLep=mcLep1MC+mcLep2MC+mcPhoMC;
    trueHistMassMC->Fill(Min((float)mcPhoDiLep.M(),(float)(xbinsMassMC[nbinsMassMCm]-0.1)),puwei*mcwei*genwei);
    responseMassMC->Fill(Min((float)mllgMC,(float)(xbinsMassD[nbinsMassDm]-0.1)),Min((float)mcPhoDiLep.M(),(float)(xbinsMassMC[nbinsMassMCm]-0.1)),puwei*mcwei*genwei);

    TLorentzVector lep1MC;
    TLorentzVector lep2MC;
    TLorentzVector phoMC;
    if(smear==0 && scale==0){ 
      lep1MC.SetPtEtaPhiM(lepPtMC[0], lepEtaMC[0], lepPhiMC[0], lepMass);
      lep2MC.SetPtEtaPhiM(lepPtMC[1], lepEtaMC[1], lepPhiMC[1], lepMass);			
      phoMC.SetPtEtaPhiM(phoPtMC, phoEtaMC, phoPhiMC, 0);
    } else if(smear==0) {
      lep1MC.SetPtEtaPhiM(lepPtMC[0]*(1.+scale*0.01), lepEtaMC[0], lepPhiMC[0], lepMass);
      lep2MC.SetPtEtaPhiM(lepPtMC[1]*(1.+scale*0.01), lepEtaMC[1], lepPhiMC[1], lepMass);			
      phoMC.SetPtEtaPhiM(phoPtMC*(1.+scale*0.01), phoEtaMC, phoPhiMC, 0);
    } else if(scale==0) {
      lep1MC.SetPtEtaPhiM(lepPtMC[0]+gRandom->Gaus(0,smear*0.01*lepPtMC[0]), lepEtaMC[0], lepPhiMC[0], lepMass);
      lep2MC.SetPtEtaPhiM(lepPtMC[1]+gRandom->Gaus(0,smear*0.01*lepPtMC[1]), lepEtaMC[1], lepPhiMC[1], lepMass);			
      phoMC.SetPtEtaPhiM(phoPtMC+gRandom->Gaus(0,smear*0.01*phoPtMC), phoEtaMC, phoPhiMC, 0);
    } else {
      lep1MC.SetPtEtaPhiM(lepPtMC[0]+gRandom->Gaus(scale*0.01*lepPtMC[0],smear*0.01*lepPtMC[0]), lepEtaMC[0], lepPhiMC[0], lepMass);
      lep2MC.SetPtEtaPhiM(lepPtMC[1]+gRandom->Gaus(scale*0.01*lepPtMC[1],smear*0.01*lepPtMC[1]), lepEtaMC[1], lepPhiMC[1], lepMass);			
      phoMC.SetPtEtaPhiM(phoPtMC+gRandom->Gaus(scale*0.01*phoPtMC,smear*0.01*phoPtMC), phoEtaMC, phoPhiMC, 0);
    }
    TLorentzVector diLepMC;
    diLepMC=lep1MC+lep2MC;
    TLorentzVector phoDiLepMC;
    phoDiLepMC=lep1MC+lep2MC+phoMC;
    //inHistMassMC->Fill(Min((float)mllgMC,(float)(xbinsMassD[nbinsMassDm]-0.1)),puwei*mcwei*genwei);
    inHistMassMC->Fill(Min((float)phoDiLepMC.M(),(float)(xbinsMassD[nbinsMassDm]-0.1)),puwei*mcwei*genwei);
    
    if(smear==0 && scale==0 && (Abs(mllgMC-phoDiLepMC.M())/mllgMC) > 0.01) 
      cout << Abs(mllgMC-phoDiLepMC.M())/mllgMC <<" mll: " << mllMC << "calc: " << diLepMC.M() << "mllg: " << mllgMC << "calc: " << phoDiLepMC.M() << endl;

    //histCheckMassMC->Fill(Min((float)phoDiLepMC.M(),(float)(xbinsMassD[nbinsMassDm]-0.1)),puwei*mcwei*genwei);
    histCheckMassMC->Fill(phoDiLepMC.M(),puwei*mcwei*genwei);
    histCheckMassNtMC->Fill(mllgMC,puwei*mcwei*genwei);
    hist2DCheckMassMC->Fill(mllgMC,phoDiLepMC.M(),1);
    histCheckMllMC->Fill(diLepMC.M(),puwei*mcwei*genwei);
    histCheckMllNtMC->Fill(mllMC,puwei*mcwei*genwei);
    hist2DCheckMllMC->Fill(mllMC,diLepMC.M(),1);
  }
  
  //check selection!!!!
  if(true) response.Fill(Min((float)phoPtMC,(float)(xbinsD[nbinsDm]-0.1)),Min((float)mcPhoPtMC,(float)(xbinsMC[nbinsMCm]-0.1)),puwei*mcwei*genwei);
  else response.Miss(Min((float)mcPhoPtMC,(float)(xbinsMC[nbinsMCm]-0.1)),puwei*mcwei*genwei);

  if(phoPtMC>15) {
    if(true) responseMass.Fill(Min((float)mllgMC,(float)(xbinsMassD[nbinsMassDm]-0.1)),Min((float)mcPhoDiLep.M(),(float)(xbinsMassMC[nbinsMassMCm]-0.1)),puwei*mcwei*genwei);
    else responseMass.Miss(Min((float)mcPhoDiLep.M(),(float)(xbinsMassMC[nbinsMassMCm]-0.1)),puwei*mcwei*genwei);
  }
}

TH2F* responseM = (TH2F*) response.Hresponse();
TH2F* responseMassM = (TH2F*) responseMass.Hresponse();

//RooUnfoldResponse response (inHistMC, trueHistMC, responseMC, "Response", "Response");

int nD = treeD->GetEntries();
for (int i=0;i<nD;i++){
  treeD->GetEntry(i);
  float w = 1.;
  for (int j=0; j<nbinsDm; j++){
    //cout << "j: " << j << " " << isEBEED << " " << fakeRateE0[j] << " " << fakeRateB0[j] << " " << fakeRateE1[j] << " " << fakeRateB1[j]<< endl;
    if ((phoPtD>xbinsD[j]) && (phoPtD<xbinsD[j+1])){
      if (channel == 0) {
	w = (isEBEED ? (1.-fakeRateE0[j]) : (1.-fakeRateB0[j]));
      } else if (channel ==1){
	w = (isEBEED ? (1.-fakeRateE1[j]) : (1.-fakeRateB1[j]));
      }
    }
  }
  
  inHist->Fill(Min((float)phoPtD,(float)(xbinsD[nbinsDm]-0.1)), w);
  if(phoPtD>15) inHistMass->Fill(Min((float)mllgD,(float)(xbinsMassD[nbinsMassDm]-0.1)), w);
  inHistBkg->Fill(Min((float)phoPtD,(float)(xbinsD[nbinsDm]-0.1)));
  if(phoPtD>15) inHistMassBkg->Fill(Min((float)mllgD,(float)(xbinsMassD[nbinsMassDm]-0.1)));

  if(phoPtD>15) {
    TLorentzVector lep1;
    lep1.SetPtEtaPhiM(lepPtD[0], lepEtaD[0], lepPhiD[0], lepMass);
    TLorentzVector lep2;
    lep2.SetPtEtaPhiM(lepPtD[1], lepEtaD[1], lepPhiD[1], lepMass);			
    TLorentzVector pho;
    pho.SetPtEtaPhiM(phoPtD, phoEtaD, phoPhiD, 0);
    TLorentzVector diLep;
    diLep=lep1+lep2;
    TLorentzVector phoDiLep;
    phoDiLep=lep1+lep2+pho;
    //histCheckMass->Fill(Min((float)phoDiLep.M(),(float)(xbinsMassD[nbinsMassDm]-0.1)),w);
    histCheckMass->Fill(phoDiLep.M(),w);
    histCheckMassNt->Fill(mllgD,w);
    hist2DCheckMass->Fill(mllgD,phoDiLep.M(),w);
    histCheckMll->Fill(diLep.M(),w);
    histCheckMllNt->Fill(mllD,w);
    hist2DCheckMll->Fill(mllD,diLep.M(),w);
  }

}

RooUnfoldBinByBin unfoldBinByBinD(&response,inHist);
RooUnfoldBinByBin unfoldBinByBinMC(&response,inHistMC);
RooUnfoldBayes unfoldBayes1D(&response,inHist,1);
RooUnfoldBayes unfoldBayes1MC(&response,inHistMC,1);
RooUnfoldBayes unfoldBayes2D(&response,inHist,2);
RooUnfoldBayes unfoldBayes2MC(&response,inHistMC,2);
RooUnfoldBayes unfoldBayes3D(&response,inHist,3);
RooUnfoldBayes unfoldBayes3MC(&response,inHistMC,3);
RooUnfoldBayes unfoldBayes4D(&response,inHist,4);
RooUnfoldBayes unfoldBayes4MC(&response,inHistMC,4);
RooUnfoldBayes unfoldBayes5D(&response,inHist,5);
RooUnfoldBayes unfoldBayes5MC(&response,inHistMC,5);
RooUnfoldSvd unfoldSvd2D(&response,inHist,2);
RooUnfoldSvd unfoldSvd2MC(&response,inHistMC,2);
RooUnfoldSvd unfoldSvd5D(&response,inHist,5);
RooUnfoldSvd unfoldSvd5MC(&response,inHistMC,5);
RooUnfoldSvd unfoldSvd8D(&response,inHist,8);
RooUnfoldSvd unfoldSvd8MC(&response,inHistMC,8);
RooUnfoldSvd unfoldSvd10D(&response,inHist,10);
RooUnfoldSvd unfoldSvd10MC(&response,inHistMC,10);

RooUnfoldBinByBin unfoldMassBinByBinD(&responseMass,inHistMass);
RooUnfoldBinByBin unfoldMassBinByBinMC(&responseMass,inHistMassMC);
RooUnfoldBayes unfoldMassBayes1D(&responseMass,inHistMass,1,smooth);
RooUnfoldBayes unfoldMassBayes1MC(&responseMass,inHistMassMC,1,smooth);
RooUnfoldBayes unfoldMassBayes2D(&responseMass,inHistMass,2,smooth);
RooUnfoldBayes unfoldMassBayes2MC(&responseMass,inHistMassMC,2,smooth);
RooUnfoldBayes unfoldMassBayes3D(&responseMass,inHistMass,3,smooth);
RooUnfoldBayes unfoldMassBayes3MC(&responseMass,inHistMassMC,3,smooth);
RooUnfoldBayes unfoldMassBayes4D(&responseMass,inHistMass,4,smooth);
RooUnfoldBayes unfoldMassBayes4MC(&responseMass,inHistMassMC,4,smooth);
RooUnfoldBayes unfoldMassBayes5D(&responseMass,inHistMass,5,smooth);
RooUnfoldBayes unfoldMassBayes5MC(&responseMass,inHistMassMC,5,smooth);
RooUnfoldSvd unfoldMassSvd2D(&responseMass,inHistMass,2);
RooUnfoldSvd unfoldMassSvd2MC(&responseMass,inHistMassMC,2);
RooUnfoldSvd unfoldMassSvd5D(&responseMass,inHistMass,5);
RooUnfoldSvd unfoldMassSvd5MC(&responseMass,inHistMassMC,5);
RooUnfoldSvd unfoldMassSvd8D(&responseMass,inHistMass,8);
RooUnfoldSvd unfoldMassSvd8MC(&responseMass,inHistMassMC,8);
RooUnfoldSvd unfoldMassSvd10D(&responseMass,inHistMass,10);
RooUnfoldSvd unfoldMassSvd10MC(&responseMass,inHistMassMC,10);

TH1F* outHistBinByBin = (TH1F*) unfoldBinByBinD.Hreco(errorTreatment);
outHistBinByBin -> SetName("outHistBinByBin");
outHistBinByBin -> SetTitle("outHistBinByBin");
TH1F* outHistBinByBinMC = (TH1F*) unfoldBinByBinMC.Hreco(errorTreatment);
outHistBinByBinMC -> SetName("outHistBinByBinMC");
outHistBinByBinMC -> SetTitle("outHistBinByBinMC");
TH1F* outHistBayes1 = (TH1F*) unfoldBayes1D.Hreco(errorTreatment);
outHistBayes1 -> SetName("outHistBayes1");
outHistBayes1 -> SetTitle("outHistBayes1");
TH1F* outHistBayes1MC = (TH1F*) unfoldBayes1MC.Hreco(errorTreatment);
outHistBayes1MC -> SetName("outHistBayes1MC");
outHistBayes1MC -> SetTitle("outHistBayes1MC");
TH1F* outHistBayes2 = (TH1F*) unfoldBayes2D.Hreco(errorTreatment);
outHistBayes2 -> SetName("outHistBayes2");
outHistBayes2 -> SetTitle("outHistBayes2");
TH1F* outHistBayes2MC = (TH1F*) unfoldBayes2MC.Hreco(errorTreatment);
outHistBayes2MC -> SetName("outHistBayes2MC");
outHistBayes2MC -> SetTitle("outHistBayes2MC");
TH1F* outHistBayes3 = (TH1F*) unfoldBayes3D.Hreco(errorTreatment);
outHistBayes3 -> SetName("outHistBayes3");
outHistBayes3 -> SetTitle("outHistBayes3");
TH1F* outHistBayes3MC = (TH1F*) unfoldBayes3MC.Hreco(errorTreatment);
outHistBayes3MC -> SetName("outHistBayes3MC");
outHistBayes3MC -> SetTitle("outHistBayes3MC");
TH1F* outHistBayes4 = (TH1F*) unfoldBayes4D.Hreco(errorTreatment);
outHistBayes4 -> SetName("outHistBayes4");
outHistBayes4 -> SetTitle("outHistBayes4");
TH1F* outHistBayes4MC = (TH1F*) unfoldBayes4MC.Hreco(errorTreatment);
outHistBayes4MC -> SetName("outHistBayes4MC");
outHistBayes4MC -> SetTitle("outHistBayes4MC");
TH1F* outHistBayes5 = (TH1F*) unfoldBayes5D.Hreco(errorTreatment);
outHistBayes5 -> SetName("outHistBayes5");
outHistBayes5 -> SetTitle("outHistBayes5");
TH1F* outHistBayes5MC = (TH1F*) unfoldBayes5MC.Hreco(errorTreatment);
outHistBayes5MC -> SetName("outHistBayes5MC");
outHistBayes5MC -> SetTitle("outHistBayes5MC");
TH1F* outHistSvd2 = (TH1F*) unfoldSvd2D.Hreco(errorTreatment);
outHistSvd2 -> SetName("outHistSvd2");
outHistSvd2 -> SetTitle("outHistSvd2");
TH1F* outHistSvd2MC = (TH1F*) unfoldSvd2MC.Hreco(errorTreatment);
outHistSvd2MC -> SetName("outHistSvd2MC");
outHistSvd2MC -> SetTitle("outHistSvd2MC");
TH1F* outHistSvd5 = (TH1F*) unfoldSvd5D.Hreco(errorTreatment);
outHistSvd5 -> SetName("outHistSvd5");
outHistSvd5 -> SetTitle("outHistSvd5");
TH1F* outHistSvd5MC = (TH1F*) unfoldSvd5MC.Hreco(errorTreatment);
outHistSvd5MC -> SetName("outHistSvd5MC");
outHistSvd5MC -> SetTitle("outHistSvd5MC");
TH1F* outHistSvd8 = (TH1F*) unfoldSvd8D.Hreco(errorTreatment);
outHistSvd8 -> SetName("outHistSvd8");
outHistSvd8 -> SetTitle("outHistSvd8");
TH1F* outHistSvd8MC = (TH1F*) unfoldSvd8MC.Hreco(errorTreatment);
outHistSvd8MC -> SetName("outHistSvd8MC");
outHistSvd8MC -> SetTitle("outHistSvd8MC");
TH1F* outHistSvd10 = (TH1F*) unfoldSvd10D.Hreco(errorTreatment);
outHistSvd10 -> SetName("outHistSvd10");
outHistSvd10 -> SetTitle("outHistSvd10");
TH1F* outHistSvd10MC = (TH1F*) unfoldSvd10MC.Hreco(errorTreatment);
outHistSvd10MC -> SetName("outHistSvd10MC");
outHistSvd10MC -> SetTitle("outHistSvd10MC");

TH1F* outHistMassBinByBin = (TH1F*) unfoldMassBinByBinD.Hreco(errorTreatment);
outHistMassBinByBin -> SetName("outHistMassBinByBin");
outHistMassBinByBin -> SetTitle("outHistMassBinByBin");
TH1F* outHistMassBinByBinMC = (TH1F*) unfoldMassBinByBinMC.Hreco(errorTreatment);
outHistMassBinByBinMC -> SetName("outHistMassBinByBinMC");
outHistMassBinByBinMC -> SetTitle("outHistMassBinByBinMC");
TH1F* outHistMassBayes1 = (TH1F*) unfoldMassBayes1D.Hreco(errorTreatment);
outHistMassBayes1 -> SetName("outHistMassBayes1");
outHistMassBayes1 -> SetTitle("outHistMassBayes1");
TH1F* outHistMassBayes1MC = (TH1F*) unfoldMassBayes1MC.Hreco(errorTreatment);
outHistMassBayes1MC -> SetName("outHistMassBayes1MC");
outHistMassBayes1MC -> SetTitle("outHistMassBayes1MC");
TH1F* outHistMassBayes2 = (TH1F*) unfoldMassBayes2D.Hreco(errorTreatment);
outHistMassBayes2 -> SetName("outHistMassBayes2");
outHistMassBayes2 -> SetTitle("outHistMassBayes2");
TH1F* outHistMassBayes2MC = (TH1F*) unfoldMassBayes2MC.Hreco(errorTreatment);
outHistMassBayes2MC -> SetName("outHistMassBayes2MC");
outHistMassBayes2MC -> SetTitle("outHistMassBayes2MC");
TH1F* outHistMassBayes3 = (TH1F*) unfoldMassBayes3D.Hreco(errorTreatment);
outHistMassBayes3 -> SetName("outHistMassBayes3");
outHistMassBayes3 -> SetTitle("outHistMassBayes3");
TH1F* outHistMassBayes3MC = (TH1F*) unfoldMassBayes3MC.Hreco(errorTreatment);
outHistMassBayes3MC -> SetName("outHistMassBayes3MC");
outHistMassBayes3MC -> SetTitle("outHistMassBayes3MC");
TH1F* outHistMassBayes4 = (TH1F*) unfoldMassBayes4D.Hreco(errorTreatment);
outHistMassBayes4 -> SetName("outHistMassBayes4");
outHistMassBayes4 -> SetTitle("outHistMassBayes4");
TH1F* outHistMassBayes4MC = (TH1F*) unfoldMassBayes4MC.Hreco(errorTreatment);
outHistMassBayes4MC -> SetName("outHistMassBayes4MC");
outHistMassBayes4MC -> SetTitle("outHistMassBayes4MC");
TH1F* outHistMassBayes5 = (TH1F*) unfoldMassBayes5D.Hreco(errorTreatment);
outHistMassBayes5 -> SetName("outHistMassBayes5");
outHistMassBayes5 -> SetTitle("outHistMassBayes5");
TH1F* outHistMassBayes5MC = (TH1F*) unfoldMassBayes5MC.Hreco(errorTreatment);
outHistMassBayes5MC -> SetName("outHistMassBayes5MC");
outHistMassBayes5MC -> SetTitle("outHistMassBayes5MC");
TH1F* outHistMassSvd2 = (TH1F*) unfoldMassSvd2D.Hreco(errorTreatment);
outHistMassSvd2 -> SetName("outHistMassSvd2");
outHistMassSvd2 -> SetTitle("outHistMassSvd2");
TH1F* outHistMassSvd2MC = (TH1F*) unfoldMassSvd2MC.Hreco(errorTreatment);
outHistMassSvd2MC -> SetName("outHistMassSvd2MC");
outHistMassSvd2MC -> SetTitle("outHistMassSvd2MC");
TH1F* outHistMassSvd5 = (TH1F*) unfoldMassSvd5D.Hreco(errorTreatment);
outHistMassSvd5 -> SetName("outHistMassSvd5");
outHistMassSvd5 -> SetTitle("outHistMassSvd5");
TH1F* outHistMassSvd5MC = (TH1F*) unfoldMassSvd5MC.Hreco(errorTreatment);
outHistMassSvd5MC -> SetName("outHistMassSvd5MC");
outHistMassSvd5MC -> SetTitle("outHistMassSvd5MC");
TH1F* outHistMassSvd8 = (TH1F*) unfoldMassSvd8D.Hreco(errorTreatment);
outHistMassSvd8 -> SetName("outHistMassSvd8");
outHistMassSvd8 -> SetTitle("outHistMassSvd8");
TH1F* outHistMassSvd8MC = (TH1F*) unfoldMassSvd8MC.Hreco(errorTreatment);
outHistMassSvd8MC -> SetName("outHistMassSvd8MC");
outHistMassSvd8MC -> SetTitle("outHistMassSvd8MC");
TH1F* outHistMassSvd10 = (TH1F*) unfoldMassSvd10D.Hreco(errorTreatment);
outHistMassSvd10 -> SetName("outHistMassSvd10");
outHistMassSvd10 -> SetTitle("outHistMassSvd10");
TH1F* outHistMassSvd10MC = (TH1F*) unfoldMassSvd10MC.Hreco(errorTreatment);
outHistMassSvd10MC -> SetName("outHistMassSvd10MC");
outHistMassSvd10MC -> SetTitle("outHistMassSvd10MC");

//inHist - outHist divide

TH1F* outHistBinByBinDivide = (TH1F*) outHistBinByBin -> Clone("outHistBinByBinDivide");
outHistBinByBinDivide -> Divide(outHistBinByBin, inHist, 1., 1.);
TH1F* outHistBinByBinMCDivide = (TH1F*) outHistBinByBinMC -> Clone("outHistBinByBinMCDivide");
outHistBinByBinMCDivide -> Divide(outHistBinByBinMC, inHistMC, 1., 1.);
TH1F* outHistBayes1Divide = (TH1F*) outHistBayes1 -> Clone("outHistBayes1Divide");
outHistBayes1Divide -> Divide(outHistBayes1, inHist, 1.,1.);
TH1F* outHistBayes1MCDivide = (TH1F*) outHistBayes1MC -> Clone("outHistBayes1MCDivide");
outHistBayes1MCDivide -> Divide(outHistBayes1MC, inHistMC, 1.,1.);
TH1F* outHistBayes2Divide = (TH1F*) outHistBayes2 -> Clone("outHistBayes2Divide"); 
outHistBayes2Divide -> Divide(outHistBayes2, inHist, 1.,1.);
TH1F* outHistBayes2MCDivide = (TH1F*) outHistBayes2MC -> Clone("outHistBayes2MCDivide");
outHistBayes2MCDivide -> Divide(outHistBayes2MC,inHistMC,1.,1.);
TH1F* outHistBayes3Divide = (TH1F*) outHistBayes3 -> Clone("outHistBayes3Divide");
outHistBayes3Divide -> Divide(outHistBayes3,inHist, 1., 1.);
TH1F* outHistBayes3MCDivide = (TH1F*) outHistBayes3MC -> Clone("outHistBayes3MCDivide");
outHistBayes3MCDivide-> Divide(outHistBayes3MC,inHistMC,1.,1.);
TH1F* outHistBayes4Divide = (TH1F*) outHistBayes4->Clone("outHistBayes4Divide");
outHistBayes4Divide->Divide(outHistBayes4,inHist,1.,1.); 
TH1F* outHistBayes4MCDivide = (TH1F*) outHistBayes4MC->Clone("outHistBayes4MCDivide");
outHistBayes4MCDivide->Divide(outHistBayes4MC,inHistMC,1.,1.);
TH1F* outHistBayes5Divide = (TH1F*) outHistBayes5-> Clone("outHistBayes5Divide");
outHistBayes5Divide->Divide(outHistBayes5,inHist, 1., 1.); 
TH1F* outHistBayes5MCDivide = (TH1F*) outHistBayes5MC->Clone("outHistBayes5MCDivide");
outHistBayes5MCDivide->Divide(outHistBayes5MC,inHistMC,1.,1.);
TH1F* outHistSvd2Divide = (TH1F*)  outHistSvd2->Clone("outHistSvd2Divide");
outHistSvd2Divide->Divide(outHistSvd2,inHist,1.,1.);
TH1F* outHistSvd2MCDivide = (TH1F*)  outHistSvd2MC->Clone("outHistSvd2MCDivide");
outHistSvd2MCDivide->Divide(outHistSvd2MC,inHistMC, 1., 1.);
TH1F* outHistSvd5Divide = (TH1F*) outHistSvd5->Clone("outHistSvd5Divide");
outHistSvd5Divide->Divide(outHistSvd5,inHist);
TH1F* outHistSvd5MCDivide = (TH1F*) outHistSvd5MC->Clone("outHistSvd5MCDivide");
outHistSvd5MCDivide->Divide(outHistSvd5MC,inHistMC, 1., 1.);
TH1F* outHistSvd8Divide = (TH1F*) outHistSvd8->Clone("outHistSvd8Divide");
outHistSvd8Divide->Divide(outHistSvd8,inHist);
TH1F* outHistSvd8MCDivide = (TH1F*) outHistSvd8MC->Clone("outHistSvd8MCDivide");
outHistSvd8MCDivide->Divide(outHistSvd8MC,inHistMC, 1., 1.);
TH1F* outHistSvd10Divide = (TH1F*) outHistSvd10->Clone("outHistSvd10Divide");
outHistSvd10Divide->Divide(outHistSvd10,inHist);
TH1F* outHistSvd10MCDivide = (TH1F*) outHistSvd10MC->Clone("outHistSvd10MCDivide");
outHistSvd10MCDivide->Divide(outHistSvd10MC,inHistMC, 1., 1.);

TH1F* outHistMassBinByBinDivide = (TH1F*)outHistMassBinByBin->Clone("outHistMassBinByBinDivide");
outHistMassBinByBinDivide->Divide(outHistMassBinByBin,inHistMass, 1., 1.);
TH1F* outHistMassBinByBinMCDivide = (TH1F*)outHistMassBinByBinMC->Clone("outHistMassBinByBinMCDivide");
outHistMassBinByBinMCDivide->Divide(outHistMassBinByBinMC,inHistMassMC, 1., 1.);
TH1F* outHistMassBayes1Divide = (TH1F*) outHistMassBayes1->Clone("outHistMassBayes1Divide");
outHistMassBayes1Divide->Divide(outHistMassBayes1,inHistMass, 1., 1.);
TH1F* outHistMassBayes1MCDivide = (TH1F*) outHistMassBayes1MC->Clone("outHistMassBayes1MCDivide");
outHistMassBayes1MCDivide->Divide(outHistMassBayes1MC,inHistMassMC, 1., 1.);
TH1F* outHistMassBayes2Divide = (TH1F*) outHistMassBayes2->Clone("outHistMassBayes2Divide");
outHistMassBayes2Divide->Divide(outHistMassBayes2,inHistMass, 1., 1.); 
TH1F* outHistMassBayes2MCDivide = (TH1F*) outHistMassBayes2MC->Clone("outHistMassBayes2MCDivide");
outHistMassBayes2MC->Divide(outHistMassBayes2MC,inHistMassMC, 1., 1.);
TH1F* outHistMassBayes3Divide = (TH1F*) outHistMassBayes3->Clone("outHistMassBayes3Divide");
outHistMassBayes3Divide->Divide(outHistMassBayes3,inHistMass, 1., 1.); 
TH1F* outHistMassBayes3MCDivide = (TH1F*) outHistMassBayes3MC->Clone("outHistMassBayes3MCDivide");
outHistMassBayes3MCDivide->Divide(outHistMassBayes3MC,inHistMassMC, 1., 1.);
TH1F* outHistMassBayes4Divide = (TH1F*) outHistMassBayes4->Clone("outHistMassBayes4Divide");
outHistMassBayes4Divide->Divide(outHistMassBayes4,inHistMass, 1., 1.); 
TH1F* outHistMassBayes4MCDivide = (TH1F*) outHistMassBayes4MC->Clone("outHistMassBayes4MCDivide");
outHistMassBayes4MCDivide->Divide(outHistMassBayes4MC,inHistMassMC, 1., 1.);
TH1F* outHistMassBayes5Divide = (TH1F*) outHistMassBayes5->Clone("outHistMassBayes5Divide");
outHistMassBayes5Divide->Divide(outHistMassBayes5,inHistMass); 
TH1F* outHistMassBayes5MCDivide = (TH1F*) outHistMassBayes5MC->Clone("outHistMassBayes5MCDivide");
outHistMassBayes5MCDivide->Divide(outHistMassBayes5MC,inHistMassMC, 1., 1.);
TH1F* outHistMassSvd2Divide = (TH1F*)  outHistMassSvd2->Clone("outHistMassSvd2Divide");
outHistMassSvd2Divide->Divide(outHistMassSvd2,inHistMass, 1., 1.);
TH1F* outHistMassSvd2MCDivide = (TH1F*)  outHistMassSvd2MC->Clone("outHistMassSvd2MCDivide");
outHistMassSvd2MCDivide->Divide(outHistMassSvd2MC,inHistMassMC, 1., 1.);
TH1F* outHistMassSvd5Divide = (TH1F*) outHistMassSvd5->Clone("outHistMassSvd5Divide");
outHistMassSvd5Divide->Divide(outHistMassSvd5,inHistMass);
TH1F* outHistMassSvd5MCDivide = (TH1F*) outHistMassSvd5MC->Clone("outHistMassSvd5MCDivide");
outHistMassSvd5MCDivide->Divide(outHistMassSvd5MC,inHistMassMC, 1., 1.);
TH1F* outHistMassSvd8Divide = (TH1F*) outHistMassSvd8->Clone("outHistMassSvd8Divide");
outHistMassSvd8Divide->Divide(outHistMassSvd8,inHistMass, 1., 1.);
TH1F* outHistMassSvd8MCDivide = (TH1F*) outHistMassSvd8MC->Clone("outHistMassSvd8MCDivide");
outHistMassSvd8MCDivide->Divide(outHistMassSvd8MC,inHistMassMC, 1., 1.);
TH1F* outHistMassSvd10Divide = (TH1F*) outHistMassSvd10->Clone("outHistMassSvd10Divide");
outHistMassSvd10Divide->Divide(outHistMassSvd10,inHistMass, 1., 1.);
TH1F* outHistMassSvd10MCDivide = (TH1F*) outHistMassSvd10MC->Clone("outHistMassSvd10MCDivide");
outHistMassSvd10MCDivide->Divide(outHistMassSvd10MC, inHistMassMC, 1., 1.);

// Gauss smearing
/*
float MCSmearPlus=gRandom->Gaus(0.01*phoPtMC,0.01*phoPtMC);
float phoPtMCSmearPlus=phoPtMC+MCSmearPlus;
float MCSmearMinus=gRandom->Gaus(-0.01*phoPtMC,0.01*phoPtMC);
float phoPtMCSmearMinus=phoPtMC+MCSmearMinus;

MCSmearPlus=gRandom->Gaus(0.01*phoEtaMC,0.01*phoEtaMC);
float phoEtaMCSmearPlus=phoEtaMC+MCSmearPlus;
MCSmearMinus=gRandom->Gaus(-0.01*phoEtaMC,0.01*phoEtaMC);
float phoEtaMCSmearMinus=phoEtaMC+MCSmearMinus;

MCSmearPlus=gRandom->Gaus(0.01*phoSCEtaMC,0.01*phoSCEtaMC);
float phoSCEtaMCSmearplus=phoSCEtaMC+MCSmearPlus;
MCSmearMinus=gRandom->Gaus(-0.01*phoSCEtaMC,0.01*phoSCEtaMC);
float phoSCEtaMCSmearMinus=phoSCEtaMC+MCSmearMinus;

MCSmearPlus=gRandom->Gaus(0.01*phoPhiMC,0.01*phoPhiMC);
float phoPhiMCSmearPlus=phoPhiMC+MCSmearPlus;
MCSmearMinus=gRandom->Gaus(-0.01*phoPhiMC,0.01*phoPhiMC);
float phoPhiMCSmearMinus=phoPhiMC+MCSmearMinus;

float lepPtMCPlus[2], lepPtMCMinus[2], lepEtaMCPlus[2],lepEtaMCMinus[2],lepSCEtaMCPlus[2], lepSCEtaMCMinus[2],lepPhiMCPlus[2], lepPhiMCPlus[2];

MCSmearPlus==gRandom->Gaus(0.01*lepPtMC[0],0.01*lepPtMC[0]);
lepPtMCPlus[0]=lepPtMC+MCSmearPlus;
MCSmearPlus==gRandom->Gaus(0.01*lepPtMC[1],0.01*lepPtMC[1]);
lepPtMCPlus[1]=lepPtMC+MCSmearPlus;
MCSmearMinus==gRandom->Gaus(-0.01*lepPtMC[0],0.01*lepPtMC[0]);
lepPtMCMinus[0]=lepPtMC+MCSmearMinus;
MCSmearMinus==gRandom->Gaus(-0.01*lepPtMC[1],0.01*lepPtMC[1]);
lepPtMCMinus[1]=lepPtMC+MCSmearMinus;

MCSmearPlus==gRandom->Gaus(0.01*lepEtaMC[0],0.01*lepEtaMC[0]);
lepEtaMCPlus[0]=lepEtaMC+MCSmearPlus;
MCSmearPlus==gRandom->Gaus(0.01*lepEtaMC[1],0.01*lepEtaMC[1]);
lepEtaMCPlus[1]=lepEtaMC+MCSmearPlus;
MCSmearMinus==gRandom->Gaus(-0.01*lepEtaMC[0],0.01*lepEtaMC[0]);
lepEtaMCMinus[0]=lepEtaMC+MCSmearMinus;
MCSmearMinus==gRandom->Gaus(-0.01*lepEtaMC[1],0.01*lepEtaMC[1]);
lepEtaMCMinus[1]=lepEtaMC+MCSmearMinus;

MCSmearPlus==gRandom->Gaus(0.01*lepSCEtaMC[0],0.01*lepSCEtaMC[0]);
lepSCEtaMCPlus[0]=lepSCEtaMC+MCSmearPlus;
MCSmearPlus==gRandom->Gaus(0.01*lepSCEtaMC[1],0.01*lepSCEtaMC[1]);
lepSCEtaMCPlus[1]=lepSCEtaMC+MCSmearPlus;
MCSmearMinus==gRandom->Gaus(-0.01*lepSCEtaMC[0],0.01*lepSCEtaMC[0]);
lepSCEtaMCMinus[0]=lepSCEtaMC+MCSmearMinus;
MCSmearMinus==gRandom->Gaus(-0.01*lepSCEtaMC[1],0.01*lepSCEtaMC[1]);
lepSCEtaMCMinus[1]=lepSCEtaMC+MCSmearMinus;

MCSmearPlus==gRandom->Gaus(0.01*lepPhiMC[0],0.01*lepPhiMC[0]);
lepPhiMCPlus[0]=lepPhiMC+MCSmearPlus;
MCSmearPlus==gRandom->Gaus(0.01*lepPhiMC[1],0.01*lepPhiMC[1]);
lepPhiMClus[1]=lepPhiMC+MCSmearPlus;
MCSmearMinus==gRandom->Gaus(-0.01*lepPhiMC[0],0.01*lepPhiMC[0]);
lepPhiMCMinus[0]=lepPhiMC+MCSmearMinus;
MCSmearMinus==gRandom->Gaus(-0.01*lepPhiMC[1],0.01*lepPhiMC[1]);
lepPhiMCMinus[1]=lepPhiMC+MCSmearMinus;

MCSmearPlus=gRandom->Gaus(0.01*mllgMC,0.01*mllgMC);
float mllgMCPlus=mllgMC+MCSmearPlus;
MCSmearMinus=gRandom->Gaus(-0.01*mllgMC,0.01*mllgMC);
float mllgMCMinus=mllgMC+MCSmearMinus;
MCSmearPlus=gRandom->Gaus(0.01*mllMC,0.01*mllMC);
float mllMCPlus=mllMC+MCSmearPlus;
MCSmearMinus=gRandom->Gaus(-0.01*mllMC,0.01*mllMC);
float mllMCMinus=mllMC+MCSmearMinus;
*/

TCanvas *ZgIn = new TCanvas("ZgIn","ZgIn",700,500);
ZgIn->Divide(3,2);
ZgIn->cd(1);
gPad->SetLogx();
inHistMCBkg->SetLineColor(kBlack);
inHistMCBkg->SetLineStyle(kDashed);
inHistMCBkg->Draw("same");
inHistMCPhoBkg->SetLineColor(kGreen);
inHistMCPhoBkg->SetLineStyle(kDashed);
inHistMCPhoBkg->Draw("same");
inHistMC->SetLineColor(kRed);
inHistMC->SetLineStyle(kDashed);
inHistMC->Draw("same");
inHistBkg->Draw("same");
inHist->SetLineColor(kGreen);
inHist->Draw("same");
ZgIn->cd(2);
gPad->SetLogx();
inHistMC->Draw();
ZgIn->cd(4);
gPad->SetLogx();
trueHistMC->Draw();
ZgIn->cd(5);
gPad->SetLogx();
gPad->SetLogy();
responseMC->Draw("text");
ZgIn->cd(6);
gPad->SetLogx();
gPad->SetLogy();
responseM->Draw("box");
string tmpString = "ZgUnfold_input"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgIn->Print(tmpChar);

TCanvas *ZgInM = new TCanvas("ZgInM","ZgInM",700,500);
ZgInM->Divide(3,2);
ZgInM->cd(1);
//gPad->SetLogx();
inHistMassMCBkg->SetLineColor(kBlack);
inHistMassMCBkg->SetLineStyle(kDashed);
inHistMassMCBkg->Draw("same");
inHistMassMCPhoBkg->SetLineColor(kGreen);
inHistMassMCPhoBkg->SetLineStyle(kDashed);
inHistMassMCPhoBkg->Draw("same");
inHistMassMC->SetLineColor(kRed);
inHistMassMC->SetLineStyle(kDashed);
inHistMassMC->Draw("same");
inHistMassBkg->Draw("same");
inHistMass->SetLineColor(kGreen);
inHistMass->Draw("same");
ZgInM->cd(2);
//gPad->SetLogx();
inHistMassMC->Draw();
ZgInM->cd(4);
//gPad->SetLogx();
trueHistMassMC->Draw();
ZgInM->cd(5);
//gPad->SetLogx();
//gPad->SetLogy();
responseMassMC->Draw("text");
ZgInM->cd(6);
//gPad->SetLogx();
//gPad->SetLogy();
responseMassM->Draw("box");
string tmpString = "ZgUnfold_inputMass"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgInM->Print(tmpChar);

TCanvas *ZgInP = new TCanvas("ZgInP","ZgInP",500,500);
ZgInP->Divide(2,2);
ZgInP->cd(1);
//gPad->SetLogx();
inHistProj->Draw();
ZgInP->cd(2);
//gPad->SetLogx();
inHistMCProj->Draw();
ZgInP->cd(3);
//gPad->SetLogx();
trueHistMCProj->Draw();
ZgInP->cd(4);
//gPad->SetLogx();
//gPad->SetLogy();
responseMCProj->Draw("text");
string tmpString = "ZgUnfold_input_projections"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgInP->Print(tmpChar);

TCanvas *ZgInMP = new TCanvas("ZgInMP","ZgInMP",500,500);
ZgInMP->Divide(2,2);
ZgInMP->cd(1);
//gPad->SetLogx();
inHistMassProj->Draw();
ZgInMP->cd(2);
//gPad->SetLogx();
inHistMassMCProj->Draw();
ZgInMP->cd(3);
//gPad->SetLogx();
//trueHistMassMCProj->Draw();
//histCheckMC->Draw();
inHistMassMC->SetLineColor(2);
inHistMassMC->SetLineStyle(2);
//inHistMassMC->Draw("same");
ZgInMP->cd(4);
//gPad->SetLogx();
//gPad->SetLogy();
//responseMassMCProj->Draw("text");
//hist2DCheckMC->Draw();
string tmpString = "ZgUnfold_inputMass_projections"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgInMP->Print(tmpChar);

TCanvas *ZgC = new TCanvas("ZgC","ZgC",900,500);
ZgC->Divide(4,2);
ZgC->cd(1);
//gPad->SetLogx();
histCheckMass->Draw();
histCheckMassNt->SetLineColor(2);
histCheckMassNt->SetLineStyle(2);
histCheckMassNt->Draw("same");
ZgC->cd(5);
//gPad->SetLogx();
//gPad->SetLogy();
hist2DCheckMass->Draw();
ZgC->cd(2);
//gPad->SetLogx();
histCheckMassMC->Draw();
histCheckMassNtMC->SetLineColor(2);
histCheckMassNtMC->SetLineStyle(2);
histCheckMassNtMC->Draw("same");
ZgC->cd(6);
//gPad->SetLogx();
//gPad->SetLogy();
hist2DCheckMassMC->Draw();
ZgC->cd(3);
//gPad->SetLogx();
histCheckMll->Draw();
histCheckMllNt->SetLineColor(2);
histCheckMllNt->SetLineStyle(2);
histCheckMllNt->Draw("same");
ZgC->cd(7);
//gPad->SetLogx();
//gPad->SetLogy();
hist2DCheckMll->Draw();
ZgC->cd(4);
//gPad->SetLogx();
histCheckMllMC->Draw();
histCheckMllNtMC->SetLineColor(2);
histCheckMllNtMC->SetLineStyle(2);
histCheckMllNtMC->Draw("same");
ZgC->cd(8);
//gPad->SetLogx();
//gPad->SetLogy();
hist2DCheckMllMC->Draw();
string tmpString = "ZgUnfold_inputMass_check"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgC->Print(tmpChar);

TCanvas *zg = new TCanvas("zg","zg",700,700);
//zg->Divide(2,2);
//zg->cd(1);
gPad->SetLogx();
inHistMC->SetLineWidth(3);
inHistMC->SetLineStyle(kDashed);
inHistMC->SetLineColor(kBlack);
inHistMC->Draw();
trueHistMC->SetLineWidth(3);
trueHistMC->SetLineStyle(kSolid);
trueHistMC->SetLineColor(kBlack);
trueHistMC->Draw("same");
outHistBinByBinMC->SetLineWidth(3);
outHistBinByBinMC->SetLineStyle(kDashed);
outHistBinByBinMC->SetLineColor(kGreen);
outHistBinByBinMC->Draw("same");
outHistBayes1MC->SetLineWidth(3);
outHistBayes1MC->SetLineStyle(kDotted);
outHistBayes1MC->SetLineColor(kBlue+3);
outHistBayes1MC->Draw("same");
outHistBayes2MC->SetLineWidth(3);
outHistBayes2MC->SetLineStyle(kDotted);
outHistBayes2MC->SetLineColor(kBlue);
outHistBayes2MC->Draw("same");
outHistBayes3MC->SetLineWidth(3);
outHistBayes3MC->SetLineStyle(kDotted);
outHistBayes3MC->SetLineColor(kBlue-7);
outHistBayes3MC->Draw("same");
outHistBayes4MC->SetLineWidth(3);
outHistBayes4MC->SetLineStyle(kDotted);
outHistBayes4MC->SetLineColor(kMagenta);
outHistBayes4MC->Draw("same");
outHistBayes5MC->SetLineWidth(3);
outHistBayes5MC->SetLineStyle(kDotted);
outHistBayes5MC->SetLineColor(kMagenta-9);
outHistBayes5MC->Draw("same");
outHistSvd2MC->SetLineWidth(3);
outHistSvd2MC->SetLineStyle(kDotted);
outHistSvd2MC->SetLineColor(kRed+2);
outHistSvd2MC->Draw("same");
outHistSvd5MC->SetLineWidth(3);
outHistSvd5MC->SetLineStyle(kDotted);
outHistSvd5MC->SetLineColor(kRed);
outHistSvd5MC->Draw("same");
outHistSvd8MC->SetLineWidth(3);
outHistSvd8MC->SetLineStyle(kDotted);
outHistSvd8MC->SetLineColor(kRed-9);
outHistSvd8MC->Draw("same");
outHistSvd10MC->SetLineWidth(3);
outHistSvd10MC->SetLineStyle(kDotted);
outHistSvd10MC->SetLineColor(kOrange);
outHistSvd10MC->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("inHistMC","inHistMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("trueHistMC","trueHistMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kSolid);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("outHistBinByBinMC","outHistBinByBinMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistBayes1MC","outHistBayes1MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistBayes2MC","outHistBayes2MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistBayes3MC","outHistBayes3MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistBayes4MC","outHistBayes4MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistBayes5MC","outHistBayes5MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistSvd2MC","outHistSvd2MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistSvd5MC","outHistSvd5MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistSvd8MC","outHistSvd8MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistSvd10MC","outHistSvd10MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_output"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
zg->Print(tmpChar);


TCanvas *zgM = new TCanvas("zgM","zgM",700,700);
//zgM->Divide(2,2);
//zgM->cd(1);
gPad->SetLogx();
trueHistMassMC->SetLineWidth(3);
trueHistMassMC->SetLineStyle(kSolid);
trueHistMassMC->SetLineColor(kBlack);
trueHistMassMC->Draw();
inHistMassMC->SetLineWidth(3);
inHistMassMC->SetLineStyle(kDashed);
inHistMassMC->SetLineColor(kBlack);
inHistMassMC->Draw("same");
outHistMassBinByBinMC->SetLineWidth(3);
outHistMassBinByBinMC->SetLineStyle(kDashed);
outHistMassBinByBinMC->SetLineColor(kGreen);
outHistMassBinByBinMC->Draw("same");
outHistMassBayes1MC->SetLineWidth(3);
outHistMassBayes1MC->SetLineStyle(kDotted);
outHistMassBayes1MC->SetLineColor(kBlue+3);
outHistMassBayes1MC->Draw("same");
outHistMassBayes2MC->SetLineWidth(3);
outHistMassBayes2MC->SetLineStyle(kDotted);
outHistMassBayes2MC->SetLineColor(kBlue);
outHistMassBayes2MC->Draw("same");
outHistMassBayes3MC->SetLineWidth(3);
outHistMassBayes3MC->SetLineStyle(kDotted);
outHistMassBayes3MC->SetLineColor(kBlue-7);
outHistMassBayes3MC->Draw("same");
outHistMassBayes4MC->SetLineWidth(3);
outHistMassBayes4MC->SetLineStyle(kDotted);
outHistMassBayes4MC->SetLineColor(kMagenta);
outHistMassBayes4MC->Draw("same");
outHistMassBayes5MC->SetLineWidth(3);
outHistMassBayes5MC->SetLineStyle(kDotted);
outHistMassBayes5MC->SetLineColor(kMagenta-9);
outHistMassBayes5MC->Draw("same");
outHistMassSvd2MC->SetLineWidth(3);
outHistMassSvd2MC->SetLineStyle(kDotted);
outHistMassSvd2MC->SetLineColor(kRed+2);
outHistMassSvd2MC->Draw("same");
outHistMassSvd5MC->SetLineWidth(3);
outHistMassSvd5MC->SetLineStyle(kDotted);
outHistMassSvd5MC->SetLineColor(kRed);
outHistMassSvd5MC->Draw("same");
outHistMassSvd8MC->SetLineWidth(3);
outHistMassSvd8MC->SetLineStyle(kDotted);
outHistMassSvd8MC->SetLineColor(kRed-9);
outHistMassSvd8MC->Draw("same");
outHistMassSvd10MC->SetLineWidth(3);
outHistMassSvd10MC->SetLineStyle(kDotted);
outHistMassSvd10MC->SetLineColor(kOrange);
outHistMassSvd10MC->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("inHistMassMC","inHistMassMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("trueHistMassMC","trueHistMassMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kSolid);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("outHistMassBinByBinMC","outHistMassBinByBinMC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistMassBayes1MC","outHistMassBayes1MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistMassBayes2MC","outHistMassBayes2MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistMassBayes3MC","outHistMassBayes3MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistMassBayes4MC","outHistMassBayes4MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistMassBayes5MC","outHistMassBayes5MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistMassSvd2MC","outHistMassSvd2MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistMassSvd5MC","outHistMassSvd5MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistMassSvd8MC","outHistMassSvd8MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistMassSvd10MC","outHistMassSvd10MC","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_outputMass"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
zgM->Print(tmpChar);

TCanvas *zgD = new TCanvas("zgD","zgD",700,700);
//zg->Divide(2,2);
//zg->cd(1);
gPad->SetLogx();
inHistBkg->SetLineWidth(3);
inHistBkg->SetLineStyle(kSolid);
inHistBkg->SetLineColor(kBlack);
inHistBkg->Draw();
inHist->SetLineWidth(3);
inHist->SetLineStyle(kDashed);
inHist->SetLineColor(kBlack);
inHist->Draw("same");
outHistBinByBin->SetLineWidth(3);
outHistBinByBin->SetLineStyle(kDashed);
outHistBinByBin->SetLineColor(kGreen);
outHistBinByBin->Draw("same");
outHistBayes1->SetLineWidth(3);
outHistBayes1->SetLineStyle(kDotted);
outHistBayes1->SetLineColor(kBlue+3);
outHistBayes1->Draw("same");
outHistBayes2->SetLineWidth(3);
outHistBayes2->SetLineStyle(kDotted);
outHistBayes2->SetLineColor(kBlue);
outHistBayes2->Draw("same");
outHistBayes3->SetLineWidth(3);
outHistBayes3->SetLineStyle(kDotted);
outHistBayes3->SetLineColor(kBlue-7);
outHistBayes3->Draw("same");
outHistBayes4->SetLineWidth(3);
outHistBayes4->SetLineStyle(kDotted);
outHistBayes4->SetLineColor(kMagenta);
outHistBayes4->Draw("same");
outHistBayes5->SetLineWidth(3);
outHistBayes5->SetLineStyle(kDotted);
outHistBayes5->SetLineColor(kMagenta-9);
outHistBayes5->Draw("same");
outHistSvd2->SetLineWidth(3);
outHistSvd2->SetLineStyle(kDotted);
outHistSvd2->SetLineColor(kRed+2);
outHistSvd2->Draw("same");
outHistSvd5->SetLineWidth(3);
outHistSvd5->SetLineStyle(kDotted);
outHistSvd5->SetLineColor(kRed);
outHistSvd5->Draw("same");
outHistSvd8->SetLineWidth(3);
outHistSvd8->SetLineStyle(kDotted);
outHistSvd8->SetLineColor(kRed-9);
outHistSvd8->Draw("same");
outHistSvd10->SetLineWidth(3);
outHistSvd10->SetLineStyle(kDotted);
outHistSvd10->SetLineColor(kOrange);
outHistSvd10->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("inHistBkg","inHistBkg","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kSolid);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("inHist","inHist","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("outHistBinByBin","outHistBinByBin","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistBayes1","outHistBayes1","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistBayes2","outHistBayes2","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistBayes3","outHistBayes3","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistBayes4","outHistBayes4","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistBayes5","outHistBayes5","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistSvd2","outHistSvd2","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistSvd5","outHistSvd5","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistSvd8","outHistSvd8","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistSvd10","outHistSvd10","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_output_data"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
zgD->Print(tmpChar);


TCanvas *zgDM = new TCanvas("zgDM","zgDM",700,700);
//zgDM->Divide(2,2);
//zgDM->cd(1);
gPad->SetLogx();
inHistMassBkg->SetLineWidth(3);
inHistMassBkg->SetLineStyle(kSolid);
inHistMassBkg->SetLineColor(kBlack);
inHistMassBkg->Draw();
inHistMass->SetLineWidth(3);
inHistMass->SetLineStyle(kDashed);
inHistMass->SetLineColor(kBlack);
inHistMass->Draw("same");
outHistMassBinByBin->SetLineWidth(3);
outHistMassBinByBin->SetLineStyle(kDashed);
outHistMassBinByBin->SetLineColor(kGreen);
outHistMassBinByBin->Draw("same");
outHistMassBayes1->SetLineWidth(3);
outHistMassBayes1->SetLineStyle(kDotted);
outHistMassBayes1->SetLineColor(kBlue+3);
outHistMassBayes1->Draw("same");
outHistMassBayes2->SetLineWidth(3);
outHistMassBayes2->SetLineStyle(kDotted);
outHistMassBayes2->SetLineColor(kBlue);
outHistMassBayes2->Draw("same");
outHistMassBayes3->SetLineWidth(3);
outHistMassBayes3->SetLineStyle(kDotted);
outHistMassBayes3->SetLineColor(kBlue-7);
outHistMassBayes3->Draw("same");
outHistMassBayes4->SetLineWidth(3);
outHistMassBayes4->SetLineStyle(kDotted);
outHistMassBayes4->SetLineColor(kMagenta);
outHistMassBayes4->Draw("same");
outHistMassBayes5->SetLineWidth(3);
outHistMassBayes5->SetLineStyle(kDotted);
outHistMassBayes5->SetLineColor(kMagenta-9);
outHistMassBayes5->Draw("same");
outHistMassSvd2->SetLineWidth(3);
outHistMassSvd2->SetLineStyle(kDotted);
outHistMassSvd2->SetLineColor(kRed+2);
outHistMassSvd2->Draw("same");
outHistMassSvd5->SetLineWidth(3);
outHistMassSvd5->SetLineStyle(kDotted);
outHistMassSvd5->SetLineColor(kRed);
outHistMassSvd5->Draw("same");
outHistMassSvd8->SetLineWidth(3);
outHistMassSvd8->SetLineStyle(kDotted);
outHistMassSvd8->SetLineColor(kRed-9);
outHistMassSvd8->Draw("same");
outHistMassSvd10->SetLineWidth(3);
outHistMassSvd10->SetLineStyle(kDotted);
outHistMassSvd10->SetLineColor(kOrange);
outHistMassSvd10->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("inHistMassBkg","inHistMassBkg","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kSolid);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("inHistMass","inHistMass","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kBlack);
entry=leg->AddEntry("outHistMassBinByBin","outHistMassBinByBin","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistMassBayes1","outHistMassBayes1","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistMassBayes2","outHistMassBayes2","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistMassBayes3","outHistMassBayes3","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistMassBayes4","outHistMassBayes4","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistMassBayes5","outHistMassBayes5","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistMassSvd2","outHistMassSvd2","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistMassSvd5","outHistMassSvd5","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistMassSvd8","outHistMassSvd8","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistMassSvd10","outHistMassSvd10","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_outputMass_data"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
zgDM->Print(tmpChar);

//Divide draw

TCanvas *ZgDivideD = new TCanvas("ZgDivide","ZgDivide",700,700);
gPad->SetLogx();
outHistBinByBinDivide->SetLineWidth(3);
outHistBinByBinDivide->SetLineStyle(kDashed);
outHistBinByBinDivide->SetLineColor(kGreen);
outHistBinByBinDivide->Draw();
outHistBayes1Divide->SetLineWidth(3);
outHistBayes1Divide->SetLineStyle(kDotted);
outHistBayes1Divide->SetLineColor(kBlue+3);
outHistBayes1Divide->Draw("same");
outHistBayes2Divide->SetLineWidth(3);
outHistBayes2Divide->SetLineStyle(kDotted);
outHistBayes2Divide->SetLineColor(kBlue);
outHistBayes2Divide->Draw("same");
outHistBayes3Divide->SetLineWidth(3);
outHistBayes3Divide->SetLineStyle(kDotted);
outHistBayes3Divide->SetLineColor(kBlue-7);
outHistBayes3Divide->Draw("same");
outHistBayes4Divide->SetLineWidth(3);
outHistBayes4Divide->SetLineStyle(kDotted);
outHistBayes4Divide->SetLineColor(kMagenta);
outHistBayes4Divide->Draw("same");
outHistBayes5Divide->SetLineWidth(3);
outHistBayes5Divide->SetLineStyle(kDotted);
outHistBayes5Divide->SetLineColor(kMagenta-9);
outHistBayes5Divide->Draw("same");
outHistSvd2Divide->SetLineWidth(3);
outHistSvd2Divide->SetLineStyle(kDotted);
outHistSvd2Divide->SetLineColor(kRed+2);
outHistSvd2Divide->Draw("same");
outHistSvd5Divide->SetLineWidth(3);
outHistSvd5Divide->SetLineStyle(kDotted);
outHistSvd5Divide->SetLineColor(kRed);
outHistSvd5Divide->Draw("same");
outHistSvd8Divide->SetLineWidth(3);
outHistSvd8Divide->SetLineStyle(kDotted);
outHistSvd8Divide->SetLineColor(kRed-9);
outHistSvd8Divide->Draw("same");
outHistSvd10Divide->SetLineWidth(3);
outHistSvd10Divide->SetLineStyle(kDotted);
outHistSvd10Divide->SetLineColor(kOrange);
outHistSvd10Divide->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("outHistBinByBinDivide","outHistBinByBinDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistBayes1Divide","outHistBayes1Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistBayes2Divide","outHistBayes2Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistBayes3Divide","outHistBayes3Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistBayes4Divide","outHistBayes4Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistBayes5Divide","outHistBayes5Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistSvd2Divide","outHistSvd2Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistSvd5Divide","outHistSvd5Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistSvd8Divide","outHistSvd8Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistSvd10Divide","outHistSvd10Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_in_out_divide"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgDivideD->Print(tmpChar);


TCanvas *ZgMCDivide = new TCanvas("ZgMCDivide","ZgMCDivide",700,700);
gPad->SetLogx();
outHistBinByBinMCDivide->SetLineWidth(3);
outHistBinByBinMCDivide->SetLineStyle(kDashed);
outHistBinByBinMCDivide->SetLineColor(kGreen);
outHistBinByBinMCDivide->Draw();
outHistBayes1MCDivide->SetLineWidth(3);
outHistBayes1MCDivide->SetLineStyle(kDotted);
outHistBayes1MCDivide->SetLineColor(kBlue+3);
outHistBayes1MCDivide->Draw("same");
outHistBayes2MCDivide->SetLineWidth(3);
outHistBayes2MCDivide->SetLineStyle(kDotted);
outHistBayes2MCDivide->SetLineColor(kBlue);
outHistBayes2MCDivide->Draw("same");
outHistBayes3MCDivide->SetLineWidth(3);
outHistBayes3MCDivide->SetLineStyle(kDotted);
outHistBayes3MCDivide->SetLineColor(kBlue-7);
outHistBayes3MCDivide->Draw("same");
outHistBayes4MCDivide->SetLineWidth(3);
outHistBayes4MCDivide->SetLineStyle(kDotted);
outHistBayes4MCDivide->SetLineColor(kMagenta);
outHistBayes4MCDivide->Draw("same");
outHistBayes5MCDivide->SetLineWidth(3);
outHistBayes5MCDivide->SetLineStyle(kDotted);
outHistBayes5MCDivide->SetLineColor(kMagenta-9);
outHistBayes5MCDivide->Draw("same");
outHistSvd2MCDivide->SetLineWidth(3);
outHistSvd2MCDivide->SetLineStyle(kDotted);
outHistSvd2MCDivide->SetLineColor(kRed+2);
outHistSvd2MCDivide->Draw("same");
outHistSvd5MCDivide->SetLineWidth(3);
outHistSvd5MCDivide->SetLineStyle(kDotted);
outHistSvd5MCDivide->SetLineColor(kRed);
outHistSvd5MCDivide->Draw("same");
outHistSvd8MCDivide->SetLineWidth(3);
outHistSvd8MCDivide->SetLineStyle(kDotted);
outHistSvd8MCDivide->SetLineColor(kRed-9);
outHistSvd8MCDivide->Draw("same");
outHistSvd10MCDivide->SetLineWidth(3);
outHistSvd10MCDivide->SetLineStyle(kDotted);
outHistSvd10MCDivide->SetLineColor(kOrange);
outHistSvd10MCDivide->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("outHistBinByBinMCDivide","outHistBinByBinMCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistBayes1MCDivide","outHistBayes1MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistBayes2MCDivide","outHistBayes2MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistBayes3MCDivide","outHistBayes3MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistBayes4MCDivide","outHistBayes4MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistBayes5MCDivide","outHistBayes5MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistSvd2MCDivide","outHistSvd2MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistSvd5MCDivide","outHistSvd5MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistSvd8MCDivide","outHistSvd8MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistSvd10MCDivide","outHistSvd10MCDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_in_out_mc_divide"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgMCDivide->Print(tmpChar);

TCanvas *ZgMassDivideD = new TCanvas("ZgMassDivide","ZgMassDivide",700,700);
gPad->SetLogx();
outHistMassBinByBinDivide->SetLineWidth(3);
outHistMassBinByBinDivide->SetLineStyle(kDashed);
outHistMassBinByBinDivide->SetLineColor(kGreen);
outHistMassBinByBinDivide->Draw();
outHistMassBayes1Divide->SetLineWidth(3);
outHistMassBayes1Divide->SetLineStyle(kDotted);
outHistMassBayes1Divide->SetLineColor(kBlue+3);
outHistMassBayes1Divide->Draw("same");
outHistMassBayes2Divide->SetLineWidth(3);
outHistMassBayes2Divide->SetLineStyle(kDotted);
outHistMassBayes2Divide->SetLineColor(kBlue);
outHistMassBayes2Divide->Draw("same");
outHistMassBayes3Divide->SetLineWidth(3);
outHistMassBayes3Divide->SetLineStyle(kDotted);
outHistMassBayes3Divide->SetLineColor(kBlue-7);
outHistMassBayes3Divide->Draw("same");
outHistMassBayes4Divide->SetLineWidth(3);
outHistMassBayes4Divide->SetLineStyle(kDotted);
outHistMassBayes4Divide->SetLineColor(kMagenta);
outHistMassBayes4Divide->Draw("same");
outHistMassBayes5Divide->SetLineWidth(3);
outHistMassBayes5Divide->SetLineStyle(kDotted);
outHistMassBayes5Divide->SetLineColor(kMagenta-9);
outHistMassBayes5Divide->Draw("same");
outHistMassSvd2Divide->SetLineWidth(3);
outHistMassSvd2Divide->SetLineStyle(kDotted);
outHistMassSvd2Divide->SetLineColor(kRed+2);
outHistMassSvd2Divide->Draw("same");
outHistMassSvd5Divide->SetLineWidth(3);
outHistMassSvd5Divide->SetLineStyle(kDotted);
outHistMassSvd5Divide->SetLineColor(kRed);
outHistMassSvd5Divide->Draw("same");
outHistMassSvd8Divide->SetLineWidth(3);
outHistMassSvd8Divide->SetLineStyle(kDotted);
outHistMassSvd8Divide->SetLineColor(kRed-9);
outHistMassSvd8Divide->Draw("same");
outHistMassSvd10Divide->SetLineWidth(3);
outHistMassSvd10Divide->SetLineStyle(kDotted);
outHistMassSvd10Divide->SetLineColor(kOrange);
outHistMassSvd10Divide->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("outHistMassBinByBinDivide","outHistMassBinByBinDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistMassBayes1Divide","outHistMassBayes1Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistMassBayes2Divide","outHistMassBayes2Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistMassBayes3Divide","outHistMassBayes3Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistMassBayes4Divide","outHistMassBayes4Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistMassBayes5Divide","outHistMassBayes5Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistMassSvd2Divide","outHistMassSvd2Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistMassSvd5Divide","outHistMassSvd5Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistMassSvd8Divide","outHistMassSvd8Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistMassSvd10Divide","outHistMassSvd10Divide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_in_out_mass_divide"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgMassDivideD->Print(tmpChar);

TCanvas *ZgMassDivideMC = new TCanvas("ZgMassMCDivide","ZgMassMCDivide",700,700);
gPad->SetLogx();
outHistMassBinByBinMCDivide->SetLineWidth(3);
outHistMassBinByBinMCDivide->SetLineStyle(kDashed);
outHistMassBinByBinMCDivide->SetLineColor(kGreen);
outHistMassBinByBinMCDivide->Draw();
outHistMassBayes1MCDivide->SetLineWidth(3);
outHistMassBayes1MCDivide->SetLineStyle(kDotted);
outHistMassBayes1MCDivide->SetLineColor(kBlue+3);
outHistMassBayes1MCDivide->Draw("same");
outHistMassBayes2MCDivide->SetLineWidth(3);
outHistMassBayes2MCDivide->SetLineStyle(kDotted);
outHistMassBayes2MCDivide->SetLineColor(kBlue);
outHistMassBayes2MCDivide->Draw("same");
outHistMassBayes3MCDivide->SetLineWidth(3);
outHistMassBayes3MCDivide->SetLineStyle(kDotted);
outHistMassBayes3MCDivide->SetLineColor(kBlue-7);
outHistMassBayes3MCDivide->Draw("same");
outHistMassBayes4MCDivide->SetLineWidth(3);
outHistMassBayes4MCDivide->SetLineStyle(kDotted);
outHistMassBayes4MCDivide->SetLineColor(kMagenta);
outHistMassBayes4MCDivide->Draw("same");
outHistMassBayes5MCDivide->SetLineWidth(3);
outHistMassBayes5MCDivide->SetLineStyle(kDotted);
outHistMassBayes5MCDivide->SetLineColor(kMagenta-9);
outHistMassBayes5MCDivide->Draw("same");
outHistMassSvd2MCDivide->SetLineWidth(3);
outHistMassSvd2MCDivide->SetLineStyle(kDotted);
outHistMassSvd2MCDivide->SetLineColor(kRed+2);
outHistMassSvd2MCDivide->Draw("same");
outHistMassSvd5MCDivide->SetLineWidth(3);
outHistMassSvd5MCDivide->SetLineStyle(kDotted);
outHistMassSvd5MCDivide->SetLineColor(kRed);
outHistMassSvd5MCDivide->Draw("same");
outHistMassSvd8MCDivide->SetLineWidth(3);
outHistMassSvd8MCDivide->SetLineStyle(kDotted);
outHistMassSvd8MCDivide->SetLineColor(kRed-9);
outHistMassSvd8MCDivide->Draw("same");
outHistMassSvd10MCDivide->SetLineWidth(3);
outHistMassSvd10MCDivide->SetLineStyle(kDotted);
outHistMassSvd10MCDivide->SetLineColor(kOrange);
outHistMassSvd10MCDivide->Draw("same");

TLegend *leg = new TLegend(0.7,0.3,0.9,0.7,NULL,"brNDC");
leg->SetTextFont(62);
leg->SetLineColor(0);
leg->SetLineStyle(1);
leg->SetLineWidth(1);
leg->SetFillColor(19);
leg->SetFillStyle(0);
TLegendEntry *entry=leg->AddEntry("outHistMassBinByBinMCDDivide","outHistMassBinByBinMCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDashed);
entry->SetLineColor(kGreen);
entry=leg->AddEntry("outHistMassBayes1MCDDivide","outHistMassBayes1MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue+3);
entry=leg->AddEntry("outHistMassBayes2MCDDivide","outHistMassBayes2MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue);
entry=leg->AddEntry("outHistMassBayes3MCDDivide","outHistMassBayes3MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kBlue-7);
entry=leg->AddEntry("outHistMassBayes4MCDDivide","outHistMassBayes4MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta);
entry=leg->AddEntry("outHistMassBayes5MCDDivide","outHistMassBayes5MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kMagenta-9);
entry=leg->AddEntry("outHistMassSvd2MCDDivide","outHistMassSvd2MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed+2);
entry=leg->AddEntry("outHistMassSvd5MCDDivide","outHistMassSvd5MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed);
entry=leg->AddEntry("outHistMassSvd8MCDDivide","outHistMassSvd8MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kRed-9);
entry=leg->AddEntry("outHistMassSvd10MCDDivide","outHistMassSvd10MCDDivide","L");
entry->SetLineWidth(3);
entry->SetLineStyle(kDotted);
entry->SetLineColor(kOrange);
leg->Draw();

string tmpString = "ZgUnfold_in_out_mass_mc_divide"+nameFragm+".pdf";
const char* tmpChar = tmpString.c_str();
ZgMassDivideMC->Print(tmpChar);

TDirectory *dir = gDirectory; 
dir->ls();

ofstream outTXT;
string tmpString = "Histos"+nameFragm+".txt";
const char* tmpChar = tmpString.c_str();
outTXT.open(tmpChar);
    
string tmpString = "Histos"+nameFragm+".root";
const char* tmpChar = tmpString.c_str();
TFile *outFile = new TFile(tmpChar,"RECREATE");

//dir->GetList()->Write();
TIter next(dir->GetList());
TObject *obj;
while ((obj=next())) {
  if (obj->InheritsFrom("TTree")) continue; //skip all TTree
  obj->Write();
  if (obj->InheritsFrom("TH2F")) continue; //skip all TH2
  TH1F *hobj = (TH1F*)obj; 
  std::vector<double> *vc = new std::vector<double>(hobj->GetNbinsX());
  std::vector<double> *ve = new std::vector<double>(hobj->GetNbinsX());
  cout << hobj->GetName() << endl;
  outTXT << hobj->GetName() << endl;
  for (int i = 0; i < hobj->GetNbinsX(); i++) {
    vc->at(i) = hobj->GetBinContent(i + 1);
    cout << vc->at(i) << " ";
    outTXT << vc->at(i) << " & ";
  }  
  cout << endl;
  outTXT << " \\\\" << endl;
  for (int i = 0; i < hobj->GetNbinsX(); i++) {
    ve->at(i) = hobj->GetBinError(i + 1);
    cout << ve->at(i) << " ";
    outTXT << ve->at(i) << " & ";
  }  
  cout << endl;
  outTXT << " \\\\" << endl;
}

outFile->Close();
outTXT.close();
return 1;
}
